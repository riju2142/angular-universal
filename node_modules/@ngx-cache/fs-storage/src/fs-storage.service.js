import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { join, resolve } from 'path';
import { mkdirSync, readdirSync, readFileSync, rmdirSync, statSync, unlinkSync, writeFileSync } from 'fs';
import { EventEmitter } from 'events';
import { Storage } from '@ngx-cache/core';
import { FsEvent } from './models/fs-event';
import { FsItemMetadata } from './models/fs-item-metadata';
import { FsStorageLoader } from './fs-storage.loader';
var FsStorageService = (function (_super) {
    tslib_1.__extends(FsStorageService, _super);
    function FsStorageService(loader) {
        var _this = _super.call(this) || this;
        _this.loader = loader;
        _this.instances = {};
        _this.path = resolve(_this.loader.path);
        _this.quota = _this.loader.quota;
        if (!!_this.instances[_this.path])
            return _this.instances[_this.path];
        _this.length = 0;
        _this.keys = [];
        _this.pid = "pid:" + process.pid;
        _this.metadata = new Map();
        _this.bytesUsed = 0;
        try {
            var stat_1 = statSync(_this.path);
            if (!!stat_1 && !stat_1.isDirectory())
                throw new Error("A file exists at the location " + _this.path + " when trying to create/open localStorage");
            _this.length = 0;
            _this.keys = readdirSync(_this.path);
            _this.bytesUsed = 0;
            var decodedKeys_1 = [];
            _this.keys.forEach(function (key, index) {
                var decodedKey = decodeURIComponent(key);
                decodedKeys_1.push(decodedKey);
                var item = new FsItemMetadata(key, index);
                _this.metadata[decodedKey] = item;
                stat_1 = _this.getStats(key);
                if (!!stat_1 && !stat_1.size) {
                    item.size = stat_1.size;
                    _this.metadata[decodedKey] = item;
                    _this.bytesUsed += stat_1.size;
                }
            });
            _this.keys = decodedKeys_1;
            _this.length = _this.keys.length;
        }
        catch (error) {
            mkdirSync(_this.path);
        }
        _this.instances[_this.path] = _this;
        return _this;
    }
    FsStorageService.prototype.setItem = function (key, value) {
        var hasListeners = EventEmitter.listenerCount(this, 'fs-storage');
        var oldValue = hasListeners ? this.getItem(key) : undefined;
        var item = this.metadata[key];
        var oldLength = !!item ? item.size : 0;
        if (this.bytesUsed - oldLength + value.toString().length > this.quota)
            throw new Error("Disk quota (" + this.quota / 1024 + "KB) has been reached!");
        var encodedKey = encodeURIComponent(key);
        var filename = join(this.path, encodedKey);
        writeFileSync(filename, value.toString(), 'utf8');
        if (!item) {
            item = new FsItemMetadata(encodedKey, (this.keys.push(key)) - 1);
            item.size = value.toString().length;
            this.length += 1;
            this.metadata[key] = item;
            this.bytesUsed += value.toString().length;
        }
        if (!hasListeners)
            return false;
        var e = new FsEvent(key, oldValue, value, this.pid);
        return this.emit('fs-storage', e);
    };
    FsStorageService.prototype.getItem = function (key) {
        var item = this.metadata[key];
        if (!!item) {
            var filename = join(this.path, item.key);
            try {
                return readFileSync(filename, 'utf8');
            }
            catch (error) {
                this.removeItem(key);
            }
        }
        return undefined;
    };
    FsStorageService.prototype.removeItem = function (key) {
        var _this = this;
        var hasListeners = EventEmitter.listenerCount(this, 'fs-storage');
        var oldValue = hasListeners ? this.getItem(key) : undefined;
        var item = this.metadata[key];
        if (!!item) {
            delete this.metadata[key];
            this.length -= 1;
            this.bytesUsed -= item.size;
            this.keys.splice(item.index, 1);
            var metadataRef = this.metadata;
            metadataRef.forEach(function (k) {
                var i = _this.metadata[k];
                if (i.index > item.index)
                    i.index -= 1;
            });
            var itemPath = join(this.path, item.key);
            try {
                this.deletePath(itemPath);
            }
            catch (error) {
            }
            if (!hasListeners)
                return false;
            var e = new FsEvent(key, oldValue, undefined, this.pid);
            return this.emit('fs-storage', e);
        }
        return false;
    };
    FsStorageService.prototype.key = function (index) {
        return this.keys[index];
    };
    FsStorageService.prototype.clear = function () {
        this.deleteDirectory(this.path);
        this.length = 0;
        this.keys = [];
        this.metadata = new Map();
        this.bytesUsed = 0;
        var hasListeners = EventEmitter.listenerCount(this, 'fs-storage');
        if (!hasListeners)
            return false;
        var e = new FsEvent(undefined, undefined, undefined, this.pid);
        return this.emit('fs-storage', e);
    };
    FsStorageService.prototype.getStats = function (key) {
        var filename = join(this.path, encodeURIComponent(key));
        try {
            return statSync(filename);
        }
        catch (error) {
            return undefined;
        }
    };
    FsStorageService.prototype.deleteDirectory = function (dirPath) {
        var _this = this;
        var contents = readdirSync(dirPath);
        var results = [];
        contents.forEach(function (path) {
            results.push(_this.deletePath(join(dirPath, path)));
        });
        return results;
    };
    FsStorageService.prototype.deletePath = function (path) {
        if (statSync(path).isDirectory()) {
            this.deleteDirectory(path);
            return rmdirSync(path);
        }
        else {
            return unlinkSync(path);
        }
    };
    FsStorageService.prototype.deleteInstance = function () {
        delete this.instances[this.path];
        this.deletePath(this.path);
        this.length = 0;
        this.keys = [];
        this.metadata = new Map();
        this.bytesUsed = 0;
    };
    return FsStorageService;
}(Storage));
export { FsStorageService };
FsStorageService.decorators = [
    { type: Injectable },
];
FsStorageService.ctorParameters = function () { return [
    { type: FsStorageLoader, },
]; };
