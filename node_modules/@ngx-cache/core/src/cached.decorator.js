import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/from';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/map';
import { ReturnType } from './models/return-type';
import { CacheService } from './cache.service';
import { isObservable, isPromise } from './util';
export function CacheKey(target, propertyKey, index) {
    var metadataKey = "__cache_" + propertyKey + "_keys";
    Array.isArray(target[metadataKey])
        ? target[metadataKey].push(index)
        : target[metadataKey] = [index];
}
export function Cached(key) {
    return function (target, propertyKey, descriptor) {
        var method = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var cache = CacheService.getInstance();
            var metadataKey = "__cache_" + propertyKey + "_keys";
            var indices = target[metadataKey];
            var keyParts = '';
            if (Array.isArray(indices))
                for (var i = 0; i < args.length; i++)
                    if (indices.indexOf(i) !== -1)
                        keyParts = !keyParts
                            ? String(args[i])
                            : keyParts + "_" + String(args[i]);
            var cacheKey = !keyParts
                ? key
                : key + "_" + keyParts;
            cacheKey = CacheService.normalizeKey(cacheKey);
            if (!cacheKey || !cache)
                return method.apply(this, args);
            if (cache.has(cacheKey)) {
                var cached = cache.getWithMetadata(cacheKey);
                if (!!cached && !!cached.data) {
                    switch (cached.returnType) {
                        case ReturnType.Observable:
                            return Observable.of(cached.data);
                        case ReturnType.Promise:
                            return Promise.resolve(cached.data);
                        default:
                            return cached.data;
                    }
                }
            }
            var value = method.apply(this, args);
            if (isObservable(value))
                return value.map(function (res) {
                    cache.set(cacheKey, res, ReturnType.Observable);
                    return res;
                });
            else if (isPromise(value))
                return value.then(function (res) {
                    cache.set(cacheKey, res, ReturnType.Promise);
                    return res;
                });
            cache.set(cacheKey, value);
            return value;
        };
        return descriptor;
    };
}
